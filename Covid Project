#Script for Covid Project

# set working directory
setwd("~/Google Drive/My Drive/MSc UEL Data Science/Quantative Data Analysis/Project")

library(ppcor)
library(psych)
library(corrgram)
library(Amelia)
library(ggplot2)
library(nFactors)
library(GPArotation)
library(cluster)
library(fpc)
library(relaimpo)

# read in data from csv file
COVID <- read.csv("COVID v6.csv", stringsAsFactors = FALSE)
head(COVID)    # Inspect top rows of the data
str(COVID)
summary(COVID)

#standardize all COVID variables
COVID <- within (COVID, pMarch_2020 <- (March_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pApril_2020 <- (April_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pMay_2020 <- (May_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pJune_2020 <- (June_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pJuly_2020 <- (July_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pAugust_2020 <- (August_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pSeptember_2020 <- (September_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pOctober_2020 <- (October_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pNovember_2020 <- (November_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pDecember_2020 <- (December_2020 / TotalPopulation)*1000)
COVID <- within (COVID, pJanuary_2021 <- (January_2021 / TotalPopulation)*1000)
COVID <- within (COVID, pFebruary_2021 <- (February_2021 / TotalPopulation)*1000)
COVID <- within (COVID, pMarch_2021 <- (March_2021 / TotalPopulation)*1000)
COVID <- within (COVID, pApril_2021 <- (April_2021 / TotalPopulation)*1000)
COVID <- within (COVID, Covid_Deaths <- (Total / TotalPopulation)*1000)

#standardize all Social Grade variables
COVID <- within (COVID, Social_Grade_AB <- (ApproximatedsocialgradeAB / Approximatedsocialgrade))
COVID <- within (COVID, Social_Grade_C1 <- (ApproximatedsocialgradeC1 / Approximatedsocialgrade))
COVID <- within (COVID, Social_Grade_C2 <- (ApproximatedsocialgradeC2 / Approximatedsocialgrade))
COVID <- within (COVID, Social_Grade_DE <- (ApproximatedsocialgradeDE / Approximatedsocialgrade))


#standardize all Deprivation variables
COVID <- within (COVID, No_deprivation <- (TOTALHouseholdisnotdeprivedinanydimension / TOTALAllcategoriesClassificationofhouseholddeprivation))
COVID <- within (COVID, Deprivation_1 <- (TOTALHouseholdisdeprivedin1dimension / TOTALAllcategoriesClassificationofhouseholddeprivation))
COVID <- within (COVID, Deprivation_2 <- (TOTALHouseholdisdeprivedin2dimensions / TOTALAllcategoriesClassificationofhouseholddeprivation))
COVID <- within (COVID, Deprivation_3 <- (TOTALHouseholdisdeprivedin3dimensions / TOTALAllcategoriesClassificationofhouseholddeprivation))
COVID <- within (COVID, Deprivation_4 <- (TOTALHouseholdisdeprivedin4dimensions / TOTALAllcategoriesClassificationofhouseholddeprivation))
COVID <- within (COVID, Deprivation <- (Deprivation_4+Deprivation_3+Deprivation_2))

#standardize other variables
COVID <- within (COVID, Urban <- (UrbanPopulation / TotalPopulation))
COVID <- within (COVID, Health_and_Disabilities_little <- (Daytodayactivitieslimitedalittle/ TotalPopulation))
COVID <- within (COVID, Health_and_Disabilities <- (Daytodayactivitieslimitedalot / TotalPopulation))
COVID <- within (COVID, No_Health_and_Disabilities <- (Daytodayactivitiesnotlimited / TotalPopulation))
COVID <- within (COVID, GDHI <- (GDHI2011))
COVID <- within (COVID, Hourly_Pay <- (FTHourlyGrossPayMean))

#observe summaries
summary(COVID$Covid_Deaths)
par("mar")
par(mar=c(3,3,3,3))

attach(COVID)


#DATA EXPLORATION
# Create boxplots of variables 
#Fig 1
boxplot(Covid_Deaths, main="Covid deaths per thousand by district", ylab="Covid deaths per thousand",col = "Bisque")
identify(rep(1, length(Covid_Deaths)), Covid_Deaths, labels = seq_along(LA_name))

#East Riding of Yorkshire 
COVID[89,]

#Fig 2
boxplot(pMarch_2020, pApril_2020, pMay_2020, pJune_2020, pJuly_2020,
        pAugust_2020, pSeptember_2020, pOctober_2020, pNovember_2020,
        pDecember_2020, pJanuary_2021, pFebruary_2021,pMarch_2021, pApril_2021,
        ylab="Covid deaths per thousand", xlab="Month", main="Monthly Covid deaths per thousand", names=c("Mar_20", "Apr_20", "pMay_20", "Jun_20", "Jul_20",
        "August_2020", "Sep_20", "Oct_20", "Nov_20", "Dec_20", "January_21", "Feb_21", "March_21", "Apr_21"),col = "Bisque")
identify(rep(1, length(Covid_Deaths)), Covid_Deaths, labels = seq_along(LA_name))

#standardize new variables
COVID <- within (COVID, Social_Grade_AB1 <- (Social_Grade_AB*100))
COVID <- within (COVID, No_deprivation1 <- (No_deprivation*100))
COVID <- within (COVID, Deprivation_11 <- (Deprivation_1*100))
COVID <- within (COVID, Deprivation_21 <- (Deprivation_2*100))
COVID <- within (COVID, Deprivation_31 <- (Deprivation_3*100))
COVID <- within (COVID, Deprivation_41 <- (Deprivation_4*100))

#Fig 3
# inspect outliers High Social Grade
boxplot(Social_Grade_AB1, ylab="Percentage %", main="Social Grade AB", col = "Bisque")
identify(rep(1, length(Social_Grade_AB1)), Social_Grade_AB1, labels = seq_along(Social_Grade_AB1))

# Fig 4 boxplot of all six percentage variables of deprivation
boxplot(No_deprivation1, Deprivation_11, 
        Deprivation_21, Deprivation_31,
        Deprivation_41,
        names=c("Any", "1 Dimension", "2 Dimension", "3 Dimension", "4 Dimension"),
        xlab="Deprivation Dimensions",  main="Household Deprivation by District",ylab="Percentage %", col = "Bisque")

#test normality
shapiro.test(Social_Grade_AB)
shapiro.test(Social_Grade_C1)
shapiro.test(Social_Grade_C2)
shapiro.test(Social_Grade_DE)
ks.test(No_deprivation, "pnorm", mean(No_deprivation), sd(No_deprivation))
ks.test(Deprivation_1, "pnorm", mean(Deprivation_1), sd(Deprivation_1))
ks.test(Deprivation, "pnorm", mean(Deprivation), sd(Deprivation))
ks.test(GDHI, "pnorm", mean(GDHI), sd(GDHI))
ks.test(Hourly_Pay, "pnorm", mean(Hourly_Pay), sd(Hourly_Pay))
ks.test(Urban, "pnorm", mean(Urban), sd(Urban))


# test correlation of dependent variable with all independent variables
cor.test(Covid_Deaths, Social_Grade_AB, method = "spearman")
cor.test(Covid_Deaths, Social_Grade_C1, method = "spearman")
cor.test(Covid_Deaths, Social_Grade_C2, method = "spearman")
cor.test(Covid_Deaths, Social_Grade_DE, method = "spearman")
cor.test(Covid_Deaths, No_deprivation, method = "spearman")
cor.test(Covid_Deaths, Deprivation_1, method = "spearman")
cor.test(Covid_Deaths, Deprivation, method = "spearman")
cor.test(Covid_Deaths, GDHI, method = "spearman")
cor.test(Covid_Deaths, Hourly_Pay, method = "spearman")
cor.test(Covid_Deaths, Urban, method = "spearman")
cor.test(Covid_Deaths, Health_and_Disabilities, method = "spearman")

# looking at internal correlations between three variables
cor.test(pDaytodayactivitiesLimitedalot, pApproximatedsocialgradeAB, method = "spearman")
cor.test(pApproximatedsocialgradeDE, pDaytodayactivitiesLimitedalot, method = "spearman")
cor.test(pApproximatedsocialgradeDE, pTOTALHouseholdisdeprivedin3dimensions, method = "spearman")
cor.test(pApproximatedsocialgradeDE, pTOTALHouseholdisdeprivedin2dimensions, method = "spearman")
cor.test(pApproximatedsocialgradeDE, pTOTALHouseholdisnotdeprivedinanydimension, method = "spearman")
cor.test(pApproximatedsocialgradeAB, pTOTALHouseholdisdeprivedin4dimensions, method = "spearman")
cor.test(pApproximatedsocialgradeAB, pTOTALHouseholdisdeprivedin3dimensions, method = "spearman")
cor.test(pApproximatedsocialgradeAB, pTOTALHouseholdisdeprivedin2dimensions, method = "spearman")
cor.test(pApproximatedsocialgradeAB, pTOTALHouseholdisnotdeprivedinanydimension, method = "spearman")

#multivariate of independent variables READY TO BE DELETED
pairs(~ Social_Grade_AB + GDHI2011 + FTHourlyGrossPayMean +
              No_deprivation,  data = COVID,
      main = "multivariate scatterplot matrix")


#spearman correlation matrix

#MATRIX FOR DEPENDENT AND INDEPENDENT VARIABLES
CovidMatrix <- data.frame(Covid_Deaths, Social_Grade_AB, 
                          Social_Grade_DE, No_deprivation,
                          Deprivation, GDHI2011, Hourly_Pay,
                          Urban, Health_and_Disabilities)
#FIG 5
pairs.panels(CovidMatrix, method = "spearman", hist.col = "grey", col = "blue", main = "Spearman Correlation Matrix")

#FIG 6
IntCorrCovidMatrix <- data.frame(Social_Grade_AB, Social_Grade_DE,
                                 No_deprivation, Deprivation, GDHI, 
                                 Hourly_Pay, Urban, Health_and_Disabilities, 
                                 main = "Indepedent Variable Correlation Matrix")

corrgram(IntCorrCovidMatrix,  main = "Indepedent Variable Correlation Matrix", 
         order=FALSE, cor.method = "pearson", lower.panel=panel.conf,
         upper.panel=panel.pie, text.panel=panel.txt)

#partial correlation - select the two independent variables which correlate 
#most strongly with the dependent variables - Deprivation, 

#1 test for partial correlation
cor.test(Covid_Deaths, Deprivation, method="spearman")
cor.test(Covid_Deaths, Urban, method="spearman")
pcor.test(Covid_Deaths, Deprivation, Urban, method="spearman")
pcor.test(Covid_Deaths, Urban, Deprivation, method="spearman")

#2 test for partial correlation
cor.test(Covid_Deaths, Social_Grade_DE, method="spearman")
cor.test(Covid_Deaths, Urban, method="spearman")
pcor.test(Covid_Deaths, Social_Grade_DE, Urban, method="spearman")
pcor.test(Covid_Deaths, Urban, Social_Grade_DE, method="spearman")

#3 test for partial correlation
cor.test(Covid_Deaths, Social_Grade_DE, method="spearman")
cor.test(Covid_Deaths, Health_and_Disabilities, method="spearman")
pcor.test(Covid_Deaths, Social_Grade_DE, Health_and_Disabilities, method="spearman")
pcor.test(Covid_Deaths, Health_and_Disabilities, Social_Grade_DE, method="spearman")

#4 test for partial correlation
cor.test(Covid_Deaths, Deprivation, method="spearman")
cor.test(Covid_Deaths, Health_and_Disabilities, method="spearman")
pcor.test(Covid_Deaths, Deprivation, Health_and_Disabilities , method="spearman")
pcor.test(Covid_Deaths, Health_and_Disabilities, Deprivation, method="spearman")

#4 test for partial correlation
cor.test(Covid_Deaths, Social_Grade_AB, method="spearman")
cor.test(Covid_Deaths, Health_and_Disabilities, method="spearman")
pcor.test(Covid_Deaths, Social_Grade_AB, Health_and_Disabilities , method="spearman")
pcor.test(Covid_Deaths, Health_and_Disabilities, Social_Grade_AB, method="spearman")

#FACTOR ANALYSIS
#create a new dataset with just IVS
COVIDFA <- read.csv("COVIDFA.csv", stringsAsFactors = FALSE)

#KMO TEST BOX4
# Kaiser-Meyer-Olkin statistics: if overall MSA > 0.6, proceed to factor analysis
KMO(cor(COVIDFA))

# get eigenvalues: eigen() uses a correlation matrix
ev <- eigen(cor(COVIDFA))
ev$values
# plot a scree plot of eigenvalues
#FIGURE 7
plot(ev$values, type="b", col="blue", xlab="variables")
# calculate cumulative proportion of eigenvalue and plot
ev.sum<-0
for(i in 1:length(ev$value)){
  ev.sum<-ev.sum+ev$value[i]
}
ev.list1<-1:length(ev$value)
for(i in 1:length(ev$value)){
  ev.list1[i]=ev$value[i]/ev.sum
}
ev.list2<-1:length(ev$value)
ev.list2[1]<-ev.list1[1]
for(i in 2:length(ev$value)){
  ev.list2[i]=ev.list2[i-1]+ev.list1[i]
}
plot (ev.list2, type="b", col="red", main = "Eigenvalues",
      xlab="number of components", ylab ="cumulative proportion")

# Varimax Rotated Principal Components
# principal() uses a data frame or matrix of correlations
fit <- principal(COVIDFA, nfactors=3, rotate="varimax")
fit

attach(COVID)

# Test dependent variable for normality
# graphically FIGURE 8
qqnorm(Covid_Deaths, xlab = "Theoretical Quantiles: Covid_Deaths" )
qqline(Covid_Deaths, col = 2) ## red color
# K-S test 
ks.test(Covid_Deaths, "pnorm", mean(Covid_Deaths), sd(Covid_Deaths))
# or... Shapiro-Wilk's test
shapiro.test(Covid_Deaths)

#MODELLING 

# Linear Regression
model1 <- lm(Covid_Deaths ~ Deprivation)

# add regression line to scatter plot #figure 8
plot(Deprivation, Covid_Deaths, main = "Scatterplot",
     xlab = "Deprivation", ylab = "Covid_Deaths")
abline(model1, col = "red")

#BOX 9
summary(model1)

hist(model1$residuals)
rug(model1$residuals)
# consider normality of residuals
plot(model1$residuals ~ model1$fitted.values, xlab = "fitted values", ylab = "residuals")
ks.test(model1$residuals, "pnorm", mean(model1$residuals), sd(model1$residuals))

#MULTIPLE LINEAR REGRESSION

# Multiple Regression
#BOX 9 Model 2 Summary and VIF
# model with all variables
model2 <- lm(Covid_Deaths ~ Deprivation + Social_Grade_AB + 
               +Social_Grade_DE + No_deprivation + Hourly_Pay + 
               Urban + Health_and_Disabilities)
summary(model2)
# calculate variance inflation factor
library(car)
vif(model2)
sqrt(vif(model2)) > 2  # if > 2 vif too high

# model with four variables
model3 <- lm(Covid_Deaths ~ No_deprivation + 
               Hourly_Pay + Urban + Health_and_Disabilities)
summary(model3) 

# Box 10 
# Calculate variance inflation factor FOUR INDEPDENT VARIABLES
vif(model3)
sqrt(vif(model3)) > 2  # if > 2 vif too high 

#calculate partial correlation
library(ppcor)
pcor.test(Covid_Deaths, No_deprivation, Health_and_Disability, method="spearman")
pcor.test(Covid_Deaths, Health_and_Disability, No_deprivation, method="spearman")
cor(Covid_Deaths, No_deprivation, method="spearman")
cor(Covid_Deaths, Health_and_Disability, method="spearman")

#THIS SHOWS URBANITY HAS NO IMPACT ON HEALTH AND 
#DISABILTIES RElATIONSHIP WITH COVID DEATHS
cor(Covid_Deaths, Urban_Households)
cor(Covid_Deaths, Health_and_Disability)
pcor.test(Covid_Deaths, Health_and_Disability, Urban_Households)
pcor.test(Covid_Deaths, Urban_Households, Health_and_Disability)

# model with three variables 
#Box 11
model4 <- lm(Covid_Deaths ~ Hourly_Pay + Urban + Health_and_Disabilities)
summary(model4) 

#Box 12
anova(model2, model4, test = "F")

#Box 13
calc.relimp(model4, type = c("lmg"), rela = TRUE)

#--END-----------------------------
# remove all variables from the environment
rm(list=ls())
